{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

-- | Database operations for COTS
module COTS.Database
  ( Database (..),
    initDatabase,
    closeDatabase,
    resetDatabase,
    snapshotDatabase,
    loadSnapshot,
    importUTXOs,
    exportUTXOs,
    getUTXOsByAddress,
    getAddressBalance,
    addTransaction,
    getTransactionHistory,
    saveProtocolParameters,
    getProtocolParameters,
    addScriptLog,
    getScriptLogs,
    addAsset,
    getAssets,
    countUTXOs,
  )
where

import COTS.Types
import Control.Monad.IO.Class (MonadIO, liftIO)
import Data.Aeson (decode, encode)
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Map.Strict as Map
import Data.Maybe (fromMaybe)
import Data.Text (Text)
import qualified Data.Text as T
import Data.Text.Encoding (decodeUtf8, encodeUtf8)
import Data.Word (Word64)
import Database.SQLite.Simple (Connection)
import qualified Database.SQLite.Simple as SQLite

-- | Database connection wrapper
data Database = Database
  { dbConnection :: SQLite.Connection,
    dbPath :: FilePath
  }

-- | Initialize database with schema
initDatabase :: FilePath -> IO Database
initDatabase path = do
  db <- SQLite.open path
  -- Create tables with simplified schema
  SQLite.execute db "CREATE TABLE IF NOT EXISTS utxos (tx_hash TEXT, tx_ix INTEGER, address TEXT, lovelace INTEGER, assets TEXT)" ()
  SQLite.execute db "CREATE TABLE IF NOT EXISTS tx_history (tx_hash TEXT, tx_type TEXT, fee INTEGER, success INTEGER)" ()
  SQLite.execute db "CREATE TABLE IF NOT EXISTS wallets (name TEXT, address TEXT)" ()
  SQLite.execute db "CREATE TABLE IF NOT EXISTS protocol_params (network TEXT, params TEXT)" ()
  SQLite.execute db "CREATE TABLE IF NOT EXISTS script_logs (script_hash TEXT, success INTEGER)" ()
  SQLite.execute db "CREATE TABLE IF NOT EXISTS assets (asset_id TEXT, name TEXT, policy_id TEXT)" ()
  return Database {dbConnection = db, dbPath = path}

-- | Close database connection
closeDatabase :: Database -> IO ()
closeDatabase Database {..} = SQLite.close dbConnection

-- | Reset database (drop all tables and recreate)
resetDatabase :: Database -> IO Database
resetDatabase db = do
  closeDatabase db
  initDatabase (dbPath db)

-- | Create a snapshot of the database
snapshotDatabase :: Database -> FilePath -> IO ()
snapshotDatabase Database {..} snapshotPath = do
  -- Simplified: just copy the file
  SQLite.execute dbConnection "VACUUM" ()

-- | Load database from snapshot
loadSnapshot :: FilePath -> FilePath -> IO Database
loadSnapshot snapshotPath targetPath = do
  -- Simplified: just open the target path
  initDatabase targetPath

-- | Import UTXOs from JSON file
importUTXOs :: Database -> [UTXO] -> IO ()
importUTXOs Database {..} utxos = do
  SQLite.execute dbConnection "BEGIN TRANSACTION" ()
  mapM_ (addUTXO dbConnection) utxos
  SQLite.execute dbConnection "COMMIT" ()
  where
    addUTXO db utxo = do
      let assetsJson = T.unpack $ decodeUtf8 $ LBS.toStrict $ encode (assets (amount utxo))
      SQLite.execute
        db
        "INSERT OR REPLACE INTO utxos (tx_hash, tx_ix, address, lovelace, assets) VALUES (?, ?, ?, ?, ?)"
        (unTransactionId (txHash utxo), unTxIndex (txIx utxo), "unknown", lovelace (amount utxo), assetsJson)

-- | Export UTXOs to list
exportUTXOs :: Database -> IO [UTXO]
exportUTXOs Database {..} = do
  rows <- SQLite.query dbConnection "SELECT tx_hash, tx_ix, address, lovelace, assets FROM utxos" ()
  mapM rowToUTXO rows
  where
    rowToUTXO (txHashStr, txIxInt, addressStr, lovelaceInt, assetsJson) = do
      let assetsMap = case decode (LBS.fromStrict (encodeUtf8 assetsJson)) of
            Just a -> a
            Nothing -> Map.empty
      return
        UTXO
          { txHash = TransactionId txHashStr,
            txIx = TxIndex (fromIntegral txIxInt),
            amount = Amount {lovelace = fromIntegral lovelaceInt, assets = assetsMap}
          }

-- | Get UTXOs by address
getUTXOsByAddress :: Database -> Address -> IO [UTXO]
getUTXOsByAddress Database {..} address = do
  rows <- SQLite.query dbConnection "SELECT tx_hash, tx_ix, address, lovelace, assets FROM utxos WHERE address = ?" (SQLite.Only (unAddress address))
  mapM rowToUTXO rows
  where
    rowToUTXO (txHashStr, txIxInt, addressStr, lovelaceInt, assetsJson) = do
      let assetsMap = case decode (LBS.fromStrict (encodeUtf8 assetsJson)) of
            Just a -> a
            Nothing -> Map.empty
      return
        UTXO
          { txHash = TransactionId txHashStr,
            txIx = TxIndex (fromIntegral txIxInt),
            amount = Amount {lovelace = fromIntegral lovelaceInt, assets = assetsMap}
          }

-- | Get address balance
getAddressBalance :: Database -> Address -> IO Word64
getAddressBalance Database {..} address = do
  rows <- SQLite.query dbConnection "SELECT SUM(lovelace) FROM utxos WHERE address = ?" (SQLite.Only (unAddress address))
  case rows of
    [SQLite.Only balance] -> return (fromIntegral balance)
    _ -> return 0

-- | Add transaction to history
addTransaction :: Database -> Text -> Text -> [TransactionInput] -> [TransactionOutput] -> Word64 -> Bool -> IO ()
addTransaction Database {..} txHash txType inputs outputs fee success = do
  let inputsJson = T.unpack $ decodeUtf8 $ LBS.toStrict $ encode inputs
      outputsJson = T.unpack $ decodeUtf8 $ LBS.toStrict $ encode outputs
  SQLite.execute
    dbConnection
    "INSERT INTO tx_history (tx_hash, tx_type, fee, success) VALUES (?, ?, ?, ?)"
    (txHash, txType, fromIntegral fee, if success then 1 else 0)

-- | Get transaction history
getTransactionHistory :: Database -> IO [(Text, Text, Word64, Bool, String)]
getTransactionHistory Database {..} = do
  rows <- SQLite.query dbConnection "SELECT tx_hash, tx_type, fee, success FROM tx_history ORDER BY rowid DESC LIMIT 100" ()
  return $ map (\(txHash, txType, fee, success) -> (txHash, txType, fromIntegral fee, success == 1, "now")) rows

-- | Save protocol parameters
saveProtocolParameters :: Database -> Network -> ProtocolParameters -> IO ()
saveProtocolParameters Database {..} network params = do
  let paramsJson = T.unpack $ decodeUtf8 $ LBS.toStrict $ encode params
  SQLite.execute
    dbConnection
    "INSERT OR REPLACE INTO protocol_params (network, params) VALUES (?, ?)"
    (T.pack (show network), paramsJson)

-- | Get protocol parameters
getProtocolParameters :: Database -> Network -> IO (Maybe ProtocolParameters)
getProtocolParameters Database {..} network = do
  rows <- SQLite.query dbConnection "SELECT params FROM protocol_params WHERE network = ? ORDER BY rowid DESC LIMIT 1" (SQLite.Only (T.pack (show network)))
  case rows of
    [SQLite.Only paramsJson] -> return $ decode (LBS.fromStrict (encodeUtf8 paramsJson))
    _ -> return Nothing

-- | Add script execution log
addScriptLog :: Database -> Text -> Maybe Datum -> Maybe Redeemer -> ExecutionUnits -> Bool -> IO ()
addScriptLog Database {..} scriptHash datum redeemer units success = do
  let unitsJson = T.unpack $ decodeUtf8 $ LBS.toStrict $ encode units
  SQLite.execute
    dbConnection
    "INSERT INTO script_logs (script_hash, success) VALUES (?, ?)"
    (scriptHash, if success then 1 else 0)

-- | Get script execution logs
getScriptLogs :: Database -> IO [(Text, Bool, String)]
getScriptLogs Database {..} = do
  rows <- SQLite.query dbConnection "SELECT script_hash, success FROM script_logs ORDER BY rowid DESC LIMIT 100" ()
  return $ map (\(scriptHash, success) -> (scriptHash, success == 1, "now")) rows

-- | Add asset
addAsset :: Database -> Text -> Maybe Text -> Maybe Text -> Maybe Text -> IO ()
addAsset Database {..} assetId assetName policyId metadata = do
  let nameJson = case assetName of
        Just n -> T.unpack n
        Nothing -> ""
  SQLite.execute
    dbConnection
    "INSERT OR REPLACE INTO assets (asset_id, name, policy_id) VALUES (?, ?, ?)"
    (assetId, nameJson, fromMaybe "" policyId)

-- | Get assets
getAssets :: Database -> IO [(Text, Maybe Text, Maybe Text)]
getAssets Database {..} = do
  rows <- SQLite.query dbConnection "SELECT asset_id, name, policy_id FROM assets" ()
  return $ map (\(assetId, name, policyId) -> (assetId, if T.null name then Nothing else Just name, if T.null policyId then Nothing else Just policyId)) rows

-- | Count UTXOs
countUTXOs :: Database -> Maybe Address -> IO Int
countUTXOs Database {..} maybeAddress = do
  case maybeAddress of
    Just address -> do
      rows <- SQLite.query dbConnection "SELECT COUNT(*) FROM utxos WHERE address = ?" (SQLite.Only (unAddress address))
      case rows of
        [SQLite.Only count] -> return count
        _ -> return 0
    Nothing -> do
      rows <- SQLite.query dbConnection "SELECT COUNT(*) FROM utxos" ()
      case rows of
        [SQLite.Only count] -> return count
        _ -> return 0